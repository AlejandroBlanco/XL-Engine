#include "input.h"
#include "settings.h"
#include <stdlib.h>
#include <string.h>
#ifdef _WIN32
	#define WIN32_LEAN_AND_MEAN 1
	#include <Windows.h>
#endif

namespace Input
{
	static char s_inputCharacters[4096] = { 0 };
	static bool s_mouseDown[3]  = { false };
	static bool s_keyState[256] = { 0 };
	static u8   s_keyPressed[256] = { 0 };
	static u8   s_keyPressedWithRepeat[256] = { 0 };
	static s32  s_mouseWheel    = 0;
	static s32  s_mouseX        = 0;
	static s32  s_mouseY        = 0;
	static void* s_winData = NULL;

	static bool s_active = false;
	void init(void* winData)
	{
		s_winData = winData;
	}

	////////////////////////////////////////////////
	//Reset state for the next frame.
	////////////////////////////////////////////////
	void finish()
	{
		s_mouseWheel = 0;
		s_inputCharacters[0] = 0;
		memset(s_keyPressed, 0, 256);
		memset(s_keyPressedWithRepeat, 0, 256);
	}

	////////////////////////////////////////////////
	//Windowing system input.
	////////////////////////////////////////////////
	void setMouseButtonState(MouseButton button, bool buttonIsDown)
	{
		if (button >= MouseCount) { return; }
		s_mouseDown[button] = buttonIsDown;
	}

	void setKeyState(u32 key, bool keyIsDown)
	{
		if (key >= 256) { return; }

		if (keyIsDown && !s_keyState[key])
		{
			s_keyPressed[key] = 1;
		}
		s_keyPressedWithRepeat[key] = keyIsDown;

		s_keyState[key] = keyIsDown;
	}

	void addChar(char c)
	{
		const size_t n = strlen(s_inputCharacters);

		//these are proper characters but should be processed by other systems.
		if (c < 0x20 || c == 0x7f)
		{
			return;
		}

		if (n + 1 < arraysize(s_inputCharacters))
		{
			s_inputCharacters[n]   = c;
			s_inputCharacters[n+1] = 0;
		}
	}

	void incMouseWheel(s32 change)
	{
		s_mouseWheel += change;
	}

	void overrideMousePos(s32 x, s32 y)
	{
		#ifdef _WIN32
			POINT pt = { x, y };
			ClientToScreen((HWND)s_winData, &pt);
			SetCursorPos(pt.x,pt.y);
		#endif
		setMousePos(x, y);
	}

	void getMouseDelta(s32* dx, s32* dy)
	{
	#ifdef _WIN32
		POINT pt = {0, 0};
		GetCursorPos(&pt);
		ScreenToClient((HWND)s_winData, &pt);

		s32 wh = Settings::get()->windowWidth  >> 1;
		s32 hh = Settings::get()->windowHeight >> 1;

		*dx = pt.x - wh;
		*dy = pt.y - hh;

		pt.x = wh; pt.y = hh;
		ClientToScreen((HWND)s_winData, &pt);
		SetCursorPos(pt.x, pt.y);
	#endif
	}

	void setMousePos(s32 x, s32 y)
	{
		s_mouseX = x;
		s_mouseY = y;
	}

	void setActive( bool active )
	{
		s_active = active;

		if (!s_active)
		{
			// Reset all the keys that are down.
			memset( s_keyState,0,sizeof(bool)*256 );
			memset( s_mouseDown,0,sizeof(bool)*3 );
		}
	}

	bool isActive()
	{
		return s_active;
	}

	////////////////////////////////////////////////
	//App interface.
	////////////////////////////////////////////////
	//is the key down
	bool keyDown(u32 key)
	{
		return s_keyState[key];
	}

	//has the key been 'pressed' (i.e. just pressed down)
	//'WithRepeat' will trigger a key pressed on every key down event
	//generated by the OS.
	bool keyPressedWithRepeat(u32 key)
	{
		return s_keyPressedWithRepeat[key]!=0;
	}

	bool keyPressed(u32 key)
	{
		return s_keyPressed[key]!=0;
	}

	//get the characters input since last frame.
	char* getCharInput()
	{
		return s_inputCharacters;
	}

	//mouse
	bool getMouseButtonState(MouseButton button)
	{
		return s_mouseDown[button];
	}

	void getMousePos(s32& x, s32& y)
	{
		x = s_mouseX;
		y = s_mouseY;
	}

	s32 getMouseWheelDelta()
	{
		return s_mouseWheel;
	}

	int mapVirtualKey(int keyCode)
	{
	#ifdef _WIN32
		if (keyCode == VK_UP)
		{
			keyCode = 0x5a;
		}
		else if (keyCode == VK_DOWN)
		{
			keyCode = 0x6a;
		}
		else if (keyCode == VK_LEFT)
		{
			keyCode = 0x6b;
		}
		else if (keyCode == VK_RIGHT)
		{
			keyCode = 0x6c;
		}
		else if (keyCode == VK_INSERT)
		{
			keyCode = 0x5e;
		}
		else if (keyCode == VK_DELETE)
		{
			keyCode = 0x5f;
		}
		else if (keyCode == VK_HOME)
		{
			keyCode = 0x61;
		}
		else if (keyCode == VK_END)
		{
			keyCode = 0x62;
		}
		else if (keyCode == VK_PRIOR)
		{
			keyCode = 0x63;
		}
		else if (keyCode == VK_NEXT)
		{
			keyCode = 0x64;
		}
		else if (keyCode == VK_LSHIFT)
		{
			keyCode = 0x2a;
		}
		else if (keyCode == VK_RSHIFT)
		{
			keyCode = 0x36;
		}
		else if (keyCode == VK_LCONTROL)
		{
			keyCode = 0x1d;
		}
		else if (keyCode == VK_RCONTROL)
		{
			keyCode = 0x66;
		}
		else
		{
			keyCode = MapVirtualKey(keyCode, MAPVK_VK_TO_VSC);
		}
		/*
		TO-DO - Add these...
		#define  sc_RightAlt     0x65
		#define  sc_RightControl 0x66
		#define  sc_kpad_Slash   0x67
		#define  sc_kpad_Enter   0x68
		#define  sc_PrintScreen  0x69
		#define  sc_LastScanCode 0x6e
		*/
	#endif
		return keyCode;
	}
};
